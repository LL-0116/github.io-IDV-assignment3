<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combined Document Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 30px; /* Espaço entre os documentos */
        }
        .document-container {
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            background-color: #ffffff;
            overflow: hidden; /* Para conter o iframe */
        }
        h2 {
            font-size: 1.5rem;
            color: #333;
            padding: 16px 24px;
            margin: 0;
            border-bottom: 1px solid #eee;
        }
        iframe {
            width: 100%;
            height: 700px; /* Altura padrão */
            border: none;
            resize: vertical; /* Permite que o usuário redimensione a altura */
            overflow: auto;
        }
    </style>
</head>
<body>

    <div class="document-container">
        <h2>Document 1: HTML Drawing with Feedback</h2>
        <iframe title="Document 1: HTML Drawing with Feedback"
                srcdoc="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
    <title>HTML Drawing with Feedback</title>
    <script src=&quot;https://cdn.tailwindcss.com&quot;></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
         
                        primary: '#1e40af',
                        secondary: '#dbeafe',
                    }
                }
            }
        }
   
     </script>
    <style type=&quot;text/tailwindcss&quot;>
        @layer utilities {
            .drawing-container {
                @apply flex flex-col items-center justify-center min-h-screen bg-secondary p-4;
            }
            .canvas-container {
                @apply bg-white p-4 rounded-lg shadow-lg;
            }
            canvas {
                @apply border border-gray-200 rounded;
                opacity: 0;
                animation: fadeIn 1.5s ease-in-out forwards;
            }
            @keyframes fadeIn {
                from { opacity: 0;
                transform: translateY(20px); }
                to { opacity: 1;
                transform: translateY(0); }
            }
            .highlight {
                filter: drop-shadow(0 0 4px rgba(30, 64, 175, 0.8));
                transition: filter 0.3s ease;
            }
            .tooltip {
                position: absolute;
                background-color: rgba(30, 64, 175, 0.9);
                color: white;
                padding: 5px 10px;
                border-radius: 4px;
                font-size: 12px;
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.3s ease;
                z-index: 10;
            }
            .doc-feedback-area {
                @apply bg-white p-6 rounded-lg shadow-lg mt-8 max-w-4xl w-full;
            }
            .doc-feedback-title {
                @apply text-xl font-bold text-primary mb-4 border-b-2 border-secondary pb-2;
            }
            .doc-feedback-item {
                @apply mb-3 flex items-start;
            }
            .doc-feedback-num {
                @apply font-bold text-primary mr-3 mt-0.5;
            }
            .doc-feedback-content {
                @apply flex-1 text-gray-700 leading-relaxed;
            }
            .images-container {
                @apply mt-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6;
            }
            .image-item {
                @apply flex flex-col items-center bg-gray-50 p-4 rounded-lg shadow;
            }
            .image-number {
                @apply font-bold text-primary text-lg mb-2;
            }
            .image-wrapper {
                @apply relative w-full overflow-hidden rounded;
            }
            .image-wrapper img {
                @apply w-full h-auto transition-transform duration-300 hover:scale-105;
            }
        }
    </style>
</head>
<body class=&quot;drawing-container&quot;>
    <div class=&quot;canvas-container relative&quot;>
        <canvas id=&quot;drawingCanvas&quot; width=&quot;500&quot; height=&quot;500&quot;></canvas>
        <div id=&quot;tooltip&quot; class=&quot;tooltip&quot;></div>
    </div>

    <div class=&quot;doc-feedback-area&quot;>
        <h2 class=&quot;doc-feedback-title&quot;>Content of Character Image Feedback.docx</h2>
        <div class=&quot;doc-feedback-item&quot;>
            <span class=&quot;doc-feedback-num&quot;>1.</span>
 
            <div class=&quot;doc-feedback-content&quot;>I provided the original image to the AI and asked it to draw the picture using HTML code.</div>
        </div>
        <div class=&quot;doc-feedback-item&quot;>
            <span class=&quot;doc-feedback-num&quot;>2.</span>
            <div class=&quot;doc-feedback-content&quot;>There were some differences between the image drawn in the previous step and the original.
So I asked the AI to adjust the details — the character should be holding a pen in one hand and paper in the other.
The pen should be drawn more completely, with a full pencil shape just like the one in the image I sent you.
I also sent a screenshot of the pencil shape from the original image.</div>
        </div>
        <div class=&quot;doc-feedback-item&quot;>
            <span class=&quot;doc-feedback-num&quot;>3.</span>
            <div class=&quot;doc-feedback-content&quot;>Add two circles on the feet, just like in the sample image.</div>
        </div>
        <div class=&quot;doc-feedback-item&quot;>
            <span class=&quot;doc-feedback-num&quot;>4.</span>
    
            <div class=&quot;doc-feedback-content&quot;>Move the intersection point of the legs and the body to the center of the top of the cube.
But this instruction may not have been clear enough, and the AI didn’t make the modification I wanted.</div>
        </div>
        <div class=&quot;doc-feedback-item&quot;>
            <span class=&quot;doc-feedback-num&quot;>5.</span>
            <div class=&quot;doc-feedback-content&quot;>Please move the legs to the same position as in the initial sample image I provided.
This instruction made the AI make a pretty good modification.</div>
        </div>
        <div class=&quot;doc-feedback-item&quot;>
            <span class=&quot;doc-feedback-num&quot;>6.</span>
            <div class=&quot;doc-feedback-content&quot;>During the previous position adjustment, the hands became separated from the body.
So I sent a request to move the top of the hands to the left to connect them with the body.
And both legs should look like the example picture.</div>
        </div>
        <div class=&quot;doc-feedback-item&quot;>
            <span class=&quot;doc-feedback-num&quot;>7.</span>
            <div class=&quot;doc-feedback-content&quot;>I continued to make some detailed adjustments: add a smaller square (slightly smaller than the head) around the facial expression.</div>
        </div>
        <div class=&quot;doc-feedback-item&quot;>
            <span 
 class=&quot;doc-feedback-num&quot;>8.</span>
            <div class=&quot;doc-feedback-content&quot;>The expression went beyond the face, so I asked the AI to make further detailed changes — make that square a bit larger and shift the facial expression to the left.</div>
        </div>
        <div class=&quot;doc-feedback-item&quot;>
            <span class=&quot;doc-feedback-num&quot;>9.</span>
            <div class=&quot;doc-feedback-content&quot;>Finally, according to the assignment requirements, I asked the AI to add the required 
 effects to the picture — move both circles on the feet to the left, and add a transition effect and an interaction effect.</div>
        </div>

        <div class=&quot;images-container&quot;>
            <div class=&quot;image-item&quot;>
                <span class=&quot;image-number&quot;>1</span>
                <div class=&quot;image-wrapper&quot;>
 
                    <img src=&quot;reference-1.png&quot; alt=&quot;Reference Image 1&quot;>
                </div>
            </div>
            <div class=&quot;image-item&quot;>
                <span class=&quot;image-number&quot;>2</span>
                <div class=&quot;image-wrapper&quot;>
  
                   <img src=&quot;reference-2.png&quot; alt=&quot;Reference Image 2&quot;>
                </div>
            </div>
            <div class=&quot;image-item&quot;>
                <span class=&quot;image-number&quot;>3</span>
                <div class=&quot;image-wrapper&quot;>
   
                  <img src=&quot;reference-3.png&quot; alt=&quot;Reference Image 3&quot;>
                </div>
            </div>
            <div class=&quot;image-item&quot;>
                <span class=&quot;image-number&quot;>4</span>
                <div class=&quot;image-wrapper&quot;>
    
                 <img src=&quot;reference-4.png&quot; alt=&quot;Reference Image 4&quot;>
                </div>
            </div>
            <div class=&quot;image-item&quot;>
                <span class=&quot;image-number&quot;>5</span>
                <div class=&quot;image-wrapper&quot;>
     
                <img src=&quot;reference-5.png&quot; alt=&quot;Reference Image 5&quot;>
                </div>
            </div>
            <div class=&quot;image-item&quot;>
                <span class=&quot;image-number&quot;>6</span>
                <div class=&quot;image-wrapper&quot;>
      
               <img src=&quot;reference-6.png&quot; alt=&quot;Reference Image 6&quot;>
                </div>
            </div>
            <div class=&quot;image-item&quot;>
                <span class=&quot;image-number&quot;>7</span>
                <div class=&quot;image-wrapper&quot;>
       
              <img src=&quot;reference-7.png&quot; alt=&quot;Reference Image 7&quot;>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Get the canvas element and context
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        
        // Define interactive regions
        const interactiveRegions = [
            {
                name: 'Head',
                x: 200,
                y: 110,
               
                 width: 100,
                height: 90,
                tooltip: 'Cube-shaped head'
            },
            {
                name: 'Face',
                x: 210,
     
                 y: 120,
                width: 80,
                height: 70,
                tooltip: 'Simple facial expression'
            },
            {
           
                 name: 'Body',
                x: 250,
                y: 200,
                width: 20,
                height: 80,
                tooltip: 'Body'
         
            },
            {
                name: 'LeftArm',
                x: 225,
                y: 230,
                width: 30,
                height: 
                 40,
                tooltip: 'Left arm holding paper'
            },
            {
                name: 'RightArm',
                x: 265,
                y: 230,
     
                 width: 40,
                height: 30,
                tooltip: 'Right arm holding pen'
            },
            {
                name: 'Paper',
          
                 x: 190,
                y: 225,
                width: 50,
                height: 45,
                tooltip: 'Paper with writing'
            },
           
             {
                name: 'Pen',
                x: 305,
                y: 240,
                width: 60,
                height: 10,
              
                 tooltip: 'Pen'
            },
            {
                name: 'LeftLeg',
                x: 230,
                y: 280,
                width: 40,
     
                 height: 100,
                tooltip: 'Left leg'
            },
            {
                name: 'RightLeg',
                x: 270,
            
                 y: 280,
                width: 40,
                height: 100,
                tooltip: 'Right leg'
            },
            {
                name: 'LeftFoot',
  
                 x: 210,
                y: 375,
                width: 40,
                height: 20,
                tooltip: 'Left foot'
            },
    
             {
                name: 'RightFoot',
                x: 290,
                y: 375,
                width: 40,
                height: 20,
       
                 tooltip: 'Right foot'
            },
            {
                name: 'Seat',
                x: 100,
                y: 300,
              
                 width: 300,
                height: 100,
                tooltip: 'Cube seat'
            }
        ];
        // Function to check if mouse is in a region
        function isMouseInRegion(mouseX, mouseY, region) {
            return mouseX >= region.x &&
                   mouseX <= region.x + region.width &&
                   mouseY >= region.y &&
                 
                   mouseY <= region.y + region.height;
        }
        
        // Mouse move event handler
        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
  
                 let hoveredRegion = null;
            
            // Check each region
            for (const region of interactiveRegions) {
                if (isMouseInRegion(mouseX, mouseY, region)) {
                    hoveredRegion = region;
 
                    break;
                }
            }
            
            // Update tooltip
            if (hoveredRegion) {
             
                 tooltip.textContent = hoveredRegion.tooltip;
                tooltip.style.left = (e.clientX + 10) + 'px';
                tooltip.style.top = (e.clientY + 10) + 'px';
                tooltip.style.opacity = '1';
                canvas.classList.add('highlight');
            } else {
   
                 tooltip.style.opacity = '0';
                canvas.classList.remove('highlight');
            }
        });
        
        // Mouse leave event handler
        canvas.addEventListener('mouseleave', function() {
            tooltip.style.opacity = '0';
            canvas.classList.remove('highlight');
        });
        // Set up the drawing style
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#1e40af';
        ctx.fillStyle = 'transparent';

        // Function to draw a cube
        function drawCube(x, y, width, height, depth) {
            // Main face (front)
            ctx.beginPath();
            ctx.rect(x, y, width, height);
            ctx.stroke();

            // Top face
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + depth, y - depth);
            ctx.lineTo(x + width + depth, y - depth);
            ctx.lineTo(x + width, y);
            ctx.closePath();
            ctx.stroke();

            // Side face
            ctx.beginPath();
            ctx.moveTo(x + width, y);
            ctx.lineTo(x + width + depth, y - depth);
            ctx.lineTo(x + width + depth, y + height - depth);
            ctx.lineTo(x + width, y + height);
            ctx.closePath();
            ctx.stroke();
        }

        // Function to draw an ellipse
        function drawEllipse(x, y, width, height) {
            ctx.beginPath();
            ctx.ellipse(x, y, width, height, 0, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Function to draw a curved hand shape
        function drawCurvedHand(x, y, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            
            // Larger curved hand shape using bezier curves - starts at (0,0) which connects to arm
            ctx.beginPath();
            ctx.moveTo(0, 0); // This point connects to the arm
            ctx.bezierCurveTo(-8, -4, -12, 6, 0, 10);
            ctx.bezierCurveTo(12, 6, 8, -4, 0, 0);
            ctx.closePath();
            ctx.stroke();
            
            ctx.restore();
        }

        // Function to draw a line
        function drawLine(x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        // Draw the base cube (the one the character is sitting on)
        drawCube(100, 300, 300, 100, 50);
        // Draw the character's body (simple lines) - matching original reference image
        drawLine(250, 200, 270, 280);
        // Body (short and tilted to the right)
        drawLine(255, 215, 225, 270);
        // Left arm (holding paper, connected to body - moved left a bit more)
        drawLine(255, 215, 305, 260);
        // Right arm (holding pencil, connected to body - moved left a bit more)

        // Draw the character's head (cube) - positioned to connect better with body
        drawCube(200, 110, 100, 90, 30);
        // Head is slightly smaller and positioned lower

        // Add a simple neck to connect head and body
        drawLine(250, 200, 260, 210);
        // Neck (short and slightly tilted)

        // Add a larger square around the face
        ctx.beginPath();
        ctx.rect(210, 120, 80, 70); // Larger square around the face (increased size)
        ctx.stroke();
        // Draw the character's face - moved left
        drawLine(225, 140, 245, 140);
        // Left eye (moved left)
        drawLine(265, 140, 285, 140);
        // Right eye (moved left)
        drawLine(225, 170, 285, 170);
        // Mouth (moved left)

        // Draw the paper in the character's left hand - matching original reference image
        ctx.beginPath();
        ctx.moveTo(225, 270);
        ctx.lineTo(200, 255);
        ctx.lineTo(210, 225);
        ctx.lineTo(240, 245);
        ctx.closePath();
        ctx.stroke();
        // Add writing details to the paper - matching original reference image
        drawLine(205, 235, 230, 250);
        drawLine(210, 245, 235, 260);
        
        // Draw a pen shape matching the reference image
        function drawPen(x, y, angle, length) {
            // Save the current context state
            ctx.save();
            // Translate and rotate the context to draw the pen at the desired angle
            ctx.translate(x, y);
            ctx.rotate(angle);
            
            // Pen body (two parallel lines)
            const bodyWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, -bodyWidth/2);
            ctx.lineTo(length - 20, -bodyWidth/2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, bodyWidth/2);
            ctx.lineTo(length - 20, bodyWidth/2);
            ctx.stroke();
            // Pen tip (long and pointed)
            ctx.beginPath();
            ctx.moveTo(length - 20, -bodyWidth/2);
            ctx.lineTo(length, 0);
            ctx.lineTo(length - 20, bodyWidth/2);
            ctx.stroke();
            // Restore the context state
            ctx.restore();
        }
        
        // Draw the pen in the character's right hand - matching original reference image
        // Calculate the angle for the pen (pointing to the paper)
        const penAngle = Math.atan2(230 - 260, 200 - 305);
        drawPen(305, 260, penAngle, 60);
        
        // Draw the character's legs with折角 moved up
        drawLine(270, 280, 230, 310);
        // Left leg (from body to折角, moved up)
        drawLine(230, 310, 230, 380);
        // Left leg (from折角 down)
        drawLine(270, 280, 310, 310);
        // Right leg (from body to折角, moved up)
        drawLine(310, 310, 310, 380);
        // Right leg (from折角 down)
        
        // Draw the character's hands (curved shape) - matching original reference image
        drawCurvedHand(225, 270, Math.PI * 0.6);
        // Left hand (holding paper, adjusted angle for new arm position)
        drawCurvedHand(305, 260, Math.PI * -0.4);
        // Right hand (holding pencil, adjusted angle for new arm position)
        
        // Draw the character's feet with rounded bottom (toes pointing left)
        // Left foot (rounded bottom, toes pointing left)
        ctx.beginPath();
        ctx.moveTo(230, 380); // Top of foot
        ctx.quadraticCurveTo(225, 395, 215, 385);
        // Rounded bottom (left side)
        ctx.quadraticCurveTo(210, 375, 230, 380);
        // Back to top
        ctx.stroke();
        // Right foot (rounded bottom, toes pointing left)
        ctx.beginPath();
        ctx.moveTo(310, 380);
        // Top of foot
        ctx.quadraticCurveTo(305, 395, 295, 385);
        // Rounded bottom (left side)
        ctx.quadraticCurveTo(290, 375, 310, 380);
        // Back to top
        ctx.stroke();
    </script>
</body>
</html>">
        </iframe>
    </div>

    <div class="document-container">
        <h2>Document 2: Cross Validation Accuracy</h2>
        <iframe title="Document 2: Cross Validation Accuracy"
                srcdoc="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
    <title>Cross Validation Accuracy</title>
    <script src=&quot;https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js&quot;></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f5f5f5;
            padding: 20px;
        }
        .chart-container {
            position: relative;
            width: 80%;
            max-width: 800px;
            height: 60vh;
            background-color: white;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        .chart-title {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .document-text {
            width: 80%;
            max-width: 800px;
            background-color: white;
            padding: 25px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 4px;
        }
        .document-text h3 {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #1f2937;
        }
        .document-text p {
            font-size: 14px;
            color: #4b5563;
            margin-bottom: 12px;
            line-height: 1.5;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .data-table th, .data-table td {
            border: 1px solid #d1d5db;
            padding: 10px;
            text-align: center;
            font-size: 14px;
        }
        .data-table th {
            background-color: #f9fafb;
            font-weight: bold;
            color: #1f2937;
        }
        /* 图片样式 */
        .image-container {
            margin: 25px 0;
        }
        .image-container .image-number {
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 8px;
            display: inline-block;
        }
        .document-text img {
            max-width: 100%;
            height: auto;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class=&quot;chart-container&quot;>
        <div class=&quot;chart-title&quot;>Cross Validation Accuracy (%)</div>
        <canvas id=&quot;accuracyChart&quot;></canvas>
    </div>

    <div class=&quot;document-text&quot;>
        <h3>1.
            Interaction Process with AI</h3>
        <p>1.
            A sample image was sent to the AI with an instruction: Present it in HTML format and add some simple interactive effects.</p>
        <p>2.
            The final product the AI gave was too complicated; to simplify it, the instruction to the AI was: No extra effects or text needed—just reproduce the image provided.</p>
        <p>3.
            The AI got confused and the chart had errors, so a further instruction was given: The dotted line part should also be changed to bars, as this is a comparison chart.</p>
        <p>4.
            After the chart content became correct, required effects were added as per assignment requirements: Add transition animations and show data details on hover.</p>

        <div class=&quot;image-container&quot;>
            <span class=&quot;image-number&quot;>1.</span>
            <img src=&quot;model_performance_1.png&quot; alt=&quot;Model Performance Comparison Chart 1&quot;>
        </div>

        <div class=&quot;image-container&quot;>
           
             <span class=&quot;image-number&quot;>2.</span>
            <img src=&quot;model_performance_2.png&quot; alt=&quot;Model Performance Comparison Chart 2&quot;>
        </div>

        <div class=&quot;image-container&quot;>
            <span class=&quot;image-number&quot;>3.</span>
            <img src=&quot;model_performance_3.png&quot; alt=&quot;Model Performance Comparison Chart 3&quot;>
        </div>

        <div class=&quot;image-container&quot;>
            <span class=&quot;image-number&quot;>4.</span>
  
           <img src=&quot;model_performance_4.png&quot; alt=&quot;Model Performance Comparison Chart 4&quot;>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const modelData = {
                models: ['BERT', 'RoBERTa', 'BART'],
                accuracy: [74.4, 
                 81.9, 73.1],
                standardDeviation: [64.8, 65.5, 63.5]
            };
            const ctx = document.getElementById('accuracyChart').getContext('2d');
            
            const dataLabelPlugin = {
                id: 'dataLabel',
                afterDraw: function(chart) {
                    const ctx = chart.ctx;
                    ctx.save();
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    
                    chart.data.datasets.forEach((dataset, datasetIndex) => {
                        const meta = chart.getDatasetMeta(datasetIndex);
                        ctx.fillStyle = datasetIndex === 0 ? '#1f2937' : '#4b5563';
                        
     
                        meta.data.forEach((bar, index) => {
                            const value = dataset.data[index];
                            const x = bar.x;
                
                             const y = chart.scales.y.getPixelForValue(value) - 10;
                            ctx.fillText(value, x, y);
                        });
                    });
                    ctx.restore();
                }
            };
            const accuracyChart = new Chart(ctx, {
                type: 'bar',
                plugins: [dataLabelPlugin],
                data: {
                    labels: modelData.models,
                    datasets: [
  
                       {
                            label: 'Cross Validation Accuracy (%)',
                            data: modelData.accuracy,
                 
                             backgroundColor: '#f59e0b',
                            borderColor: '#d97706',
                            borderWidth: 1,
                            borderRadius: 0,
 
                             barPercentage: 0.4,
                            categoryPercentage: 0.6
                        },
                   
             {
                            label: 'Standard Deviation',
                            data: modelData.standardDeviation,
                            backgroundColor: '#d1d5db',
       
                             borderColor: '#9ca3af',
                            borderWidth: 1,
                            borderRadius: 0,
                    
                 barPercentage: 0.4,
                            categoryPercentage: 0.6
                        }
                    ]
                },
  
                 options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                      
                     legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
           
                             backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleFont: { size: 16, weight: 'bold' },
                            bodyFont: { size: 14 },
             
                             padding: 15,
                            cornerRadius: 6,
                            boxPadding: 5,
                          
                     usePointStyle: true,
                            callbacks: {
                                title: (context) => `Model: ${context[0].label}`,
                                
                                 label: (context) => {
                                    let label = context.dataset.label + ': ';
                                    label += context.datasetIndex === 1 ? '±' : '';
                                    label += context.parsed.y;
                                    label += context.datasetIndex === 0 ?
                                     '%' : '';
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
  
                       y: {
                            beginAtZero: true,
                            max: 100,
                   
                             grid: { display: false },
                            ticks: { stepSize: 20, font: { family: 'Arial', size: 12 } }
                        },
                        
                         x: {
                            grid: { display: false },
                            ticks: { font: { family: 'Arial', size: 14, weight: 'bold' } }
                        }
    
                 },
                    animation: {
                        duration: 1500,
                        easing: 'easeOutQuart',
             
                         animations: {
                            backgroundColor: { type: 'color', duration: 500, easing: 'easeInOutQuad' },
                            borderColor: { type: 'color', duration: 500, easing: 'easeInOutQuad' },
                
                             y: { type: 'number', duration: 1000, easing: 'easeOutQuart', from: (ctx) => ctx.chart.scales.y.max }
                        }
                    },
                    interaction: { mode: 'nearest', axis: 'x', intersect: false },
    
                 elements: {
                        bar: {
                            backgroundColor: (context) => {
                           
                             const hovered = context.chart.tooltip._active.some(active => active.dataIndex === context.dataIndex && active.datasetIndex === context.datasetIndex);
                                return hovered ?
                                 (context.datasetIndex === 0 ? '#fbbf24' : '#e5e7eb') : (context.datasetIndex === 0 ? '#f59e0b' : '#d1d5db');
                            },
                            borderWidth: (context) => {
                                const hovered = context.chart.tooltip._active.some(active => active.dataIndex === context.dataIndex && active.datasetIndex === context.datasetIndex);
                                return hovered ? 2 : 1;
                            }
                        }
                    }
                }
            });
            document.getElementById('accuracyChart').addEventListener('mousemove', function(evt) {
                const points = accuracyChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
                this.style.cursor = points.length ? 'pointer' : 'default';
            });
        });
    </script>
</body>
</html>">
        </iframe>
    </div>

    <div class="document-container">
        <h2>Document 3: Venn Diagram</h2>
        <iframe title="Document 3: Venn Diagram"
                srcdoc="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
    <title>维恩图交互演示</title>
    <script src=&quot;https://cdn.tailwindcss.com&quot;></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
    
                        primary: '#8a4fff',
                        secondary: '#ffd166',
                        tertiary: '#d4a373',
                        dark: '#333333',
    
                        light: '#f8f9fa'
                    }
                }
            }
        }
    </script>
    <style type=&quot;text/tailwindcss&quot;>
        @layer utilities {
    
                .venn-section {
                cursor: pointer;
                transition: all 0.3s ease;
                opacity: 0;
            }
            .venn-section:hover {
                filter: brightness(1.2);
                transform: scale(1.03);
            }
            .pulse {
                animation: pulse 2s infinite;
            }
            @keyframes pulse {
                0% { transform: scale(1);
            }
                50% { transform: scale(1.08);
            }
                100% { transform: scale(1);
            }
            }
            .fade-in {
                animation: fadeIn 0.5s ease-in-out;
            }
            @keyframes fadeIn {
                from { opacity: 0;
            }
                to { opacity: 1;
            }
            }
            /* 飞入动画 */
            .fly-in-left {
                animation: flyInLeft 1s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            }
            .fly-in-top {
                animation: flyInTop 1s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            }
            .fly-in-right {
                animation: flyInRight 1s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            }
            .fade-in-delayed {
                animation: fadeIn 0.8s ease-out forwards;
            }
            
            @keyframes flyInLeft {
                from {
                    opacity: 0;
                    transform: translate(-200px, 50px) scale(0.5);
                }
                to {
                    opacity: 1;
                    transform: translate(0, 0) scale(1);
                }
            }
            
            @keyframes flyInTop {
                from {
                    opacity: 0;
                    transform: translate(0, -200px) scale(0.5);
                }
                to {
                    opacity: 1;
                    transform: translate(0, 0) scale(1);
                }
            }
            
            @keyframes flyInRight {
                from {
                    opacity: 0;
                    transform: translate(200px, 50px) scale(0.5);
                }
                to {
                    opacity: 1;
                    transform: translate(0, 0) scale(1);
                }
            }
            
            /* 延迟动画 */
            .delay-300 { animation-delay: 0.3s;
            }
            .delay-600 { animation-delay: 0.6s;
            }
            .delay-900 { animation-delay: 0.9s;
            }
            .delay-1200 { animation-delay: 1.2s;
            }
            .delay-1500 { animation-delay: 1.5s;
            }
        }
    </style>
</head>
<body class=&quot;bg-light min-h-screen flex flex-col items-center justify-center p-4&quot;>
    <div class=&quot;bg-white rounded-xl shadow-lg p-8 fade-in w-full max-w-4xl&quot;>
        <div class=&quot;relative w-full max-w-2xl aspect-square mx-auto&quot;>
            <svg viewBox=&quot;0 0 500 400&quot; class=&quot;w-full h-full&quot;>
               
                 <defs>
                    <linearGradient id=&quot;gradI&quot; x1=&quot;0%&quot; y1=&quot;0%&quot; x2=&quot;100%&quot; y2=&quot;100%&quot;>
                        <stop offset=&quot;0%&quot; stop-color=&quot;#8a4fff&quot; stop-opacity=&quot;0.7&quot; />
     
                        <stop offset=&quot;100%&quot; stop-color=&quot;#8a4fff&quot; stop-opacity=&quot;0.4&quot; />
                    </linearGradient>
                    
                    <linearGradient id=&quot;gradII&quot; x1=&quot;0%&quot; y1=&quot;0%&quot; x2=&quot;100%&quot; y2=&quot;100%&quot;>
                        <stop offset=&quot;0%&quot; stop-color=&quot;#d4a373&quot; stop-opacity=&quot;0.7&quot; />
                        <stop offset=&quot;100%&quot; stop-color=&quot;#d4a373&quot; stop-opacity=&quot;0.4&quot; />
                    </linearGradient>
             
        
                    <linearGradient id=&quot;gradIII&quot; x1=&quot;0%&quot; y1=&quot;0%&quot; x2=&quot;100%&quot; y2=&quot;100%&quot;>
                        <stop offset=&quot;0%&quot; stop-color=&quot;#ffd166&quot; stop-opacity=&quot;0.7&quot; />
                 
                        <stop offset=&quot;100%&quot; stop-color=&quot;#ffd166&quot; stop-opacity=&quot;0.4&quot; />
                    </linearGradient>
                </defs>
                
                <circle cx=&quot;150&quot; cy=&quot;200&quot; 
                 r=&quot;130&quot; fill=&quot;url(#gradI)&quot; class=&quot;venn-section fly-in-left&quot; data-section=&quot;I&quot; />
                <circle cx=&quot;300&quot; cy=&quot;150&quot; r=&quot;130&quot; fill=&quot;url(#gradII)&quot; class=&quot;venn-section fly-in-top delay-300&quot; data-section=&quot;II&quot; />
                <circle cx=&quot;300&quot; cy=&quot;250&quot; r=&quot;130&quot; fill=&quot;url(#gradIII)&quot; class=&quot;venn-section fly-in-right delay-600&quot; data-section=&quot;III&quot; />
                
                <text x=&quot;80&quot; y=&quot;200&quot; font-family=&quot;Arial&quot; font-size=&quot;28&quot; font-weight=&quot;bold&quot; text-anchor=&quot;middle&quot; fill=&quot;white&quot; class=&quot;venn-section fade-in-delayed delay-300&quot;>I</text>
                <text x=&quot;300&quot; y=&quot;70&quot; font-family=&quot;Arial&quot; font-size=&quot;28&quot; font-weight=&quot;bold&quot; text-anchor=&quot;middle&quot; fill=&quot;white&quot; class=&quot;venn-section fade-in-delayed delay-600&quot;>II</text>
                <text x=&quot;370&quot; y=&quot;290&quot; font-family=&quot;Arial&quot; font-size=&quot;28&quot; font-weight=&quot;bold&quot; text-anchor=&quot;middle&quot; fill=&quot;white&quot; class=&quot;venn-section fade-in-delayed delay-900&quot;>III</text>
                <text x=&quot;210&quot; y=&quot;140&quot; font-family=&quot;Arial&quot; font-size=&quot;22&quot; font-weight=&quot;bold&quot; text-anchor=&quot;middle&quot; fill=&quot;white&quot; class=&quot;venn-section fade-in-delayed delay-1200&quot;>IV</text>
       
                 <text x=&quot;300&quot; y=&quot;170&quot; font-family=&quot;Arial&quot; font-size=&quot;22&quot; font-weight=&quot;bold&quot; text-anchor=&quot;middle&quot; fill=&quot;white&quot; class=&quot;venn-section fade-in-delayed delay-1200&quot;>V</text>
                <text x=&quot;200&quot; y=&quot;260&quot; font-family=&quot;Arial&quot; font-size=&quot;22&quot; font-weight=&quot;bold&quot; text-anchor=&quot;middle&quot; fill=&quot;white&quot; class=&quot;venn-section fade-in-delayed delay-1200&quot;>VI</text>
                <text x=&quot;240&quot; y=&quot;190&quot; font-family=&quot;Arial&quot; font-size=&quot;20&quot; font-weight=&quot;bold&quot; text-anchor=&quot;middle&quot; fill=&quot;white&quot; class=&quot;venn-section fade-in-delayed delay-1500&quot;>VII</text>
           
             </svg>
            
            <div class=&quot;absolute -top-10 left-1/2 transform -translate-x-1/2 text-xl font-bold text-tertiary&quot;>Replace</div>
            <div class=&quot;absolute -left-16 top-1/2 transform -translate-y-1/2 text-xl font-bold text-primary&quot;>Delete</div>
            <div class=&quot;absolute -right-20 top-1/2 transform -translate-y-1/2 text-xl font-bold text-secondary&quot;>Rewrite</div>
        </div>
     
        
        <div class=&quot;mt-12 border-t border-gray-200 pt-8&quot;>
            <h2 class=&quot;text-2xl font-bold text-dark mb-6&quot;>Venn Diagram Revision Instructions</h2>
            <div class=&quot;space-y-4 text-gray-700&quot;>
                <div class=&quot;p-3 bg-gray-50 rounded-lg&quot;>
                    <h3 class=&quot;font-bold text-primary&quot;>1.
                        Initial Request</h3>
                    <p>I sent a sample image to the AI with the instruction: Present it in HTML format and add some simple interactive effects.</p>
                </div>
                <div class=&quot;p-3 bg-gray-50 rounded-lg&quot;>
                    <h3 class=&quot;font-bold text-primary&quot;>2.
                        First Revision</h3>
                    <p>The AI generated many pages with effects, but failed to properly create the most crucial Venn diagram.
                        So I input the instruction: No text explanation needed. Just fully represent the elements in the image, along with hover effects and transition animations.</p>
                </div>
                <div class=&quot;p-3 bg-gray-50 rounded-lg&quot;>
                    <h3 class=&quot;font-bold text-primary&quot;>3.
                        Second Revision</h3>
                    <p>The AI-generated page had inappropriate effects, and the Venn diagram was still incorrectly displayed.
                        Therefore, I gave more detailed instructions: Add a gradual appearance effect for patterns or text, remove the animation effect of the yellow circle, and regenerate the Venn diagram as the overlapping parts of the large circles are unreasonably designed.</p>
                </div>
                <div class=&quot;p-3 bg-gray-50 rounded-lg&quot;>
                    <h3 class=&quot;font-bold text-primary&quot;>4.
                        Adding Labels</h3>
                    <p>After detailed revisions, the Venn diagram became correct but lacked labels.
                        So I sent the instruction: Mark the overlapping parts of the three large circles with IV, V, and VI respectively.</p>
                </div>
                <div class=&quot;p-3 bg-gray-50 rounded-lg&quot;>
                    <h3 class=&quot;font-bold text-primary&quot;>5.
                        Adjusting Display and Effects</h3>
                    <p>The circles in the diagram were not fully displayed, and additional effects were needed.
                        Thus, I input the instruction: Enlarge the screen a bit to fully show the three large circles, and add a direct fly-in effect for the three circles.</p>
                </div>
                <div class=&quot;p-3 bg-gray-50 rounded-lg&quot;>
                    <h3 class=&quot;font-bold text-primary&quot;>6.
                        Correcting Label Positions</h3>
                    <p>The details in the Venn diagram were still not accurate enough, so I asked the AI to make revisions with the instruction: The position of VI is marked incorrectly—it should be in the overlapping area of the yellow and purple circles.
                        Move III down a bit and do not place it in the overlapping area.
                        Remove the small circle under VII, but keep VII's position unchanged.</p>
                </div>
                <div class=&quot;p-3 bg-gray-50 rounded-lg&quot;>
                    <h3 class=&quot;font-bold text-primary&quot;>7.
                        Final Adjustments</h3>
                    <p>Finally, some further detailed revisions were needed.
                        The instruction was: Move VI down a bit to the overlapping area of the large purple and yellow circles, and move IV up a bit.</p>
                </div>
            </div>
            
            <div class=&quot;mt-10 space-y-12&quot;>
        
                 <div class=&quot;flex items-start gap-6&quot;>
                    <div class=&quot;text-4xl font-bold text-primary min-w-[40px]&quot;>1</div>
                    <div class=&quot;flex-1&quot;>
                        <img src=&quot;venn-image-1.png&quot; 
 
                             alt=&quot;维恩图示例1&quot; 
                             class=&quot;rounded-lg shadow-md w-full max-w-lg mx-auto hover:shadow-lg transition-shadow duration-300&quot;>
                    </div>
              
                 </div>
                
                <div class=&quot;flex items-start gap-6&quot;>
                    <div class=&quot;text-4xl font-bold text-primary min-w-[40px]&quot;>2</div>
                    <div 
                 class=&quot;flex-1&quot;>
                        <img src=&quot;venn-image-2.png&quot; 
                             alt=&quot;维恩图示例2&quot; 
                             class=&quot;rounded-lg shadow-md w-full max-w-lg mx-auto hover:shadow-lg transition-shadow duration-300&quot;>
        
                     </div>
                </div>
                
                <div class=&quot;flex items-start gap-6&quot;>
                   
                 <div class=&quot;text-4xl font-bold text-primary min-w-[40px]&quot;>3</div>
                    <div class=&quot;flex-1&quot;>
                        <img src=&quot;venn-image-3.png&quot; 
                             alt=&quot;维恩图示例3&quot; 
                  
                    class=&quot;rounded-lg shadow-md w-full max-w-lg mx-auto hover:shadow-lg transition-shadow duration-300&quot;>
                    </div>
                </div>
                
                <div class=&quot;flex items-start gap-6&quot;>
                    <div class=&quot;text-4xl font-bold text-primary min-w-[40px]&quot;>4</div>
                    <div class=&quot;flex-1&quot;>
                        <img src=&quot;venn-image-4.png&quot; 
                      
                        alt=&quot;维恩图示例4&quot; 
                             class=&quot;rounded-lg shadow-md w-full max-w-lg mx-auto hover:shadow-lg transition-shadow duration-300&quot;>
                    </div>
                </div>
            </div>
        
         </div>
    </div>

    <script>
        // 等待DOM加载完成
        document.addEventListener('DOMContentLoaded', function() {
            // 获取所有维恩图区域
            const vennSections = document.querySelectorAll('.venn-section');
            // 为每个维恩图区域添加事件监听器
            vennSections.forEach(section => {
                // 鼠标悬停事件 - 进入效果
                section.addEventListener('mouseenter', function() {
                    this.style.filter = 'brightness(1.3)';
                    this.style.transform = 'scale(1.05)';
    
                 
                    // 为非黄色圆圈添加脉冲效果
                    if (this.getAttribute('data-section') !== &quot;III&quot;) {
                        this.classList.add('pulse');
               
                     }
                });
                
                // 鼠标离开事件 - 恢复效果
                section.addEventListener('mouseleave', function() {
                    this.style.filter = 'brightness(1)';
    
                     this.style.transform = 'scale(1)';
                    this.classList.remove('pulse');
                });
            });
        });
    </script>
</body>
</html>">
        </iframe>
    </div>

    <div class="document-container">
        <h2>Document 4: Data Visualization Charts</h2>
        <iframe title="Document 4: Data Visualization Charts"
                srcdoc="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;>
    <title>Data Visualization Charts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .chart-container {
            display: flex;
            gap: 40px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .chart {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        h2 {
            color: #333;
            margin-bottom: 5px;
        }
        
        h3 {
            color: #666;
            margin-top: 0;
            font-weight: normal;
        }
        
        canvas {
            border: 1px solid #eee;
            margin-top: 10px;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 20px;
        }
        
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        /* 文档内容样式 */
        .document-content {
            width: 880px;
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-top: 40px;
        }
        
        .document-content h3 {
            color: #333;
            font-weight: 600;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        
        .document-content ol {
            padding-left: 20px;
            line-height: 1.8;
            color: #555;
        }
        
        .document-content li {
            margin-bottom: 10px;
        }

        /* 图片展示区域样式 */
        .images-container {
            width: 880px;
            margin-top: 30px;
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .image-item {
            display: flex;
            align-items: center;
            gap: 20px;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .image-number {
            font-size: 20px;
            font-weight: bold;
            color: #4CAF50;
            min-width: 30px;
            text-align: center;
        }

        .image-container img {
            max-width: 100%;
            border-radius: 4px;
            border: 1px solid #eee;
        }
    </style>
</head>
<body>
    <div>
        <h2>Data Visualization</h2>
        <h3>Probability Distribution &amp; Position-Related Curve</h3>
    </div>
    
    <div class=&quot;chart-container&quot;>
        <div class=&quot;chart&quot;>
            <h3>Probability Distribution</h3>
            <canvas id=&quot;probabilityChart&quot; width=&quot;400&quot; height=&quot;300&quot;></canvas>
  
           <div id=&quot;probabilityTooltip&quot; class=&quot;tooltip&quot;></div>
        </div>
        
        <div class=&quot;chart&quot;>
            <h3>Position-Related Curve</h3>
            <canvas id=&quot;positionChart&quot; width=&quot;400&quot; height=&quot;300&quot;></canvas>
            <div id=&quot;positionTooltip&quot; class=&quot;tooltip&quot;></div>
        
         </div>
    </div>
    
    <div class=&quot;controls&quot;>
        <button id=&quot;resetBtn&quot;>Reset Animation</button>
    </div>

    <div class=&quot;document-content&quot;>
        <h3>Operation &amp; Requirement Record</h3>
        <ol>
            <li>I sent the sample image to the AI with the instruction: Present it in HTML format and add some simple interactive effects.</li>
          
           <li>The result the AI gave me had very low similarity to the sample image, so I made a clear request for an identical version with the instruction: No need to make it so complicated—just replicate the image I provided exactly.</li>
            <li>At this point, since the code Doubao gave me had relatively low accuracy, I went to Gemini and entered the first instruction.
             It smoothly provided a piece of code with very high similarity.
             I then copied this code to Doubao for detailed modifications and gave the relevant instruction: Help me revise this code—extend the dotted line on the right image to align with the solid line below, and add a transition effect to one image and an interactive effect to the other (one each for the two images).</li>
            <li>After the modification, inconsistencies appeared in the right image, so I made another modification request: The lines on the right image are different from my original one;
             please correct this. There’s no need to make the image effect too complicated.
             Then I successfully obtained code with a high degree of similarity.</li>
        </ol>
    </div>

    <div class=&quot;images-container&quot;>
        <div class=&quot;image-item&quot;>
            <div class=&quot;image-number&quot;>1</div>
            <div class=&quot;image-container&quot;>
                <img src=&quot;chart-image-1.png&quot; alt=&quot;Image 1&quot;>
            </div>
 
         </div>
        <div class=&quot;image-item&quot;>
            <div class=&quot;image-number&quot;>2</div>
            <div class=&quot;image-container&quot;>
                <img src=&quot;chart-image-2.png&quot; alt=&quot;Image 2&quot;>
            </div>
        </div>
        <div class=&quot;image-item&quot;>
          
           <div class=&quot;image-number&quot;>3</div>
            <div class=&quot;image-container&quot;>
                <img src=&quot;chart-image-3.png&quot; alt=&quot;Image 3&quot;>
            </div>
        </div>
    </div>

    <script>
        // Get canvas contexts
        const probCtx = document.getElementById('probabilityChart').getContext('2d');
        const posCtx = document.getElementById('positionChart').getContext('2d');
        
        // Get tooltips
        const probTooltip = document.getElementById('probabilityTooltip');
        const posTooltip = document.getElementById('positionTooltip');
        
        // Animation progress variables
        let probAnimationProgress = 0;
        let posAnimationProgress = 0;
        
        // Animation IDs
        let probAnimationId = null;
        let posAnimationId = null;
        
        // Probability chart data
        const probData = {
            p1: 0.2, // Low probability
            p2: 0.6, // High probability
            regions: []
        };
        // Position chart data
        const posData = {
            curvePoints: [],
            dashedPoints: []
        };
        // Initialize the application
        function init() {
            startAnimations();
            setupEventListeners();
        }
        
        // Start all animations
        function startAnimations() {
            // Reset progress
            probAnimationProgress = 0;
            posAnimationProgress = 0;
            
            // Cancel existing animations
            if (probAnimationId) cancelAnimationFrame(probAnimationId);
            if (posAnimationId) cancelAnimationFrame(posAnimationId);
            
            // Start new animations
            animateProbabilityChart();
            animatePositionChart();
        }
        
        // Animate probability distribution chart
        function animateProbabilityChart() {
            // Clear canvas
            probCtx.clearRect(0, 0, 400, 300);
            // Draw axes
            drawAxes(probCtx, 400, 300);
            // Draw chart elements with animation
            const width = 400;
            const height = 300;
            const margin = 40;
            const innerWidth = width - 2 * margin;
            const innerHeight = height - 2 * margin;
            
            // Calculate positions
            const p1Y = height - margin - innerHeight * probData.p1;
            const p2Y = height - margin - innerHeight * probData.p2;
            const i_n = margin + innerWidth * 0.2;
            const iDn_n = margin + innerWidth * 0.4;
            const x1 = margin + innerWidth * 0.8;
            // Draw p1 and p2 lines
            probCtx.beginPath();
            probCtx.setLineDash([5, 3]);
            probCtx.strokeStyle = '#666';
            probCtx.moveTo(margin, p1Y);
            probCtx.lineTo(width - margin, p1Y);
            probCtx.moveTo(margin, p2Y);
            probCtx.lineTo(width - margin, p2Y);
            probCtx.stroke();
            probCtx.setLineDash([]);
            // Draw labels
            probCtx.fillStyle = '#333';
            probCtx.font = '12px Arial';
            probCtx.textAlign = 'right';
            probCtx.fillText('(Low) p₁', margin - 5, p1Y + 4);
            probCtx.fillText('(High) p₂', margin - 5, p2Y + 4);
            
            probCtx.textAlign = 'center';
            probCtx.fillText('i/n', i_n, height - margin + 15);
            probCtx.fillText('(i+Δn)/n', iDn_n, height - margin + 15);
            probCtx.fillText('1', width - margin, height - margin + 15);
            // Draw left region with animation
            const leftRegionWidth = (iDn_n - i_n) * probAnimationProgress;
            probCtx.fillStyle = 'rgba(150, 100, 200, 0.5)';
            probCtx.fillRect(i_n, p2Y, leftRegionWidth, p1Y - p2Y);
            // Draw left region border
            probCtx.beginPath();
            probCtx.setLineDash([5, 3]);
            probCtx.strokeStyle = '#666';
            probCtx.strokeRect(i_n, p2Y, leftRegionWidth, p1Y - p2Y);
            probCtx.stroke();
            probCtx.setLineDash([]);
            // Draw right dashed box
            probCtx.beginPath();
            probCtx.setLineDash([5, 3]);
            probCtx.strokeStyle = '#666';
            probCtx.strokeRect(x1, p2Y, innerWidth * 0.15, p1Y - p2Y);
            probCtx.stroke();
            probCtx.setLineDash([]);
            // Draw bottom region with animation
            const bottomRegionWidth = (width - 2 * margin) * probAnimationProgress;
            probCtx.fillStyle = 'rgba(150, 100, 200, 0.3)';
            probCtx.fillRect(margin, p1Y, bottomRegionWidth, (height - margin) - p1Y);
            // Draw arrow with animation
            const arrowProgress = Math.min(probAnimationProgress * 2, 1);
            if (arrowProgress > 0) {
                probCtx.beginPath();
                probCtx.moveTo(iDn_n, (p1Y + p2Y) / 2);
                probCtx.lineTo(iDn_n + (x1 - iDn_n) * arrowProgress, (p1Y + p2Y) / 2);
                probCtx.strokeStyle = '#333';
                probCtx.stroke();
                
                // Draw arrow head
                if (arrowProgress > 0.9) {
                    probCtx.beginPath();
                    probCtx.moveTo(x1, (p1Y + p2Y) / 2);
                    probCtx.lineTo(x1 - 5, (p1Y + p2Y) / 2 - 5);
                    probCtx.lineTo(x1 - 5, (p1Y + p2Y) / 2 + 5);
                    probCtx.fillStyle = '#333';
                    probCtx.fill();
                }
            }
            
            // Update regions for interaction
            probData.regions = [
                {
                    x: i_n,
         
                     y: p2Y,
                    width: iDn_n - i_n,
                    height: p1Y - p2Y,
                    label: 'High Probability Region',
                   
                     value: `p₂ - p₁ = ${(probData.p2 - probData.p1).toFixed(2)}`
                },
                {
                    x: margin,
                    y: p1Y,
                  
                     width: width - 2 * margin,
                    height: (height - margin) - p1Y,
                    label: 'Low Probability Region',
                    value: `p₁ = ${probData.p1.toFixed(2)}`
                }
      
             ];
            
            // Continue animation
            if (probAnimationProgress < 1) {
                probAnimationProgress += 0.01;
                probAnimationId = requestAnimationFrame(animateProbabilityChart);
            }
        }
        
        // Animate position-related curve chart
        function animatePositionChart() {
            // Clear canvas
            posCtx.clearRect(0, 0, 400, 300);
            // Draw axes
            drawAxes(posCtx, 400, 300);
            // Draw chart elements with animation
            const width = 400;
            const height = 300;
            const margin = 40;
            const innerWidth = width - 2 * margin;
            const innerHeight = height - 2 * margin;
            
            // Generate curve points if not already generated
            if (posData.curvePoints.length === 0) {
                generateCurvePoints();
            }
            
            // Draw solid curve with animation
            posCtx.beginPath();
            posCtx.strokeStyle = 'green';
            posCtx.lineWidth = 2;
            
            const solidPointsToDraw = Math.floor(posData.curvePoints.length * posAnimationProgress);
            for (let i = 0; i < solidPointsToDraw; i++) {
                if (i === 0) {
                    posCtx.moveTo(posData.curvePoints[i].x, posData.curvePoints[i].y);
                } else {
                    posCtx.lineTo(posData.curvePoints[i].x, posData.curvePoints[i].y);
                }
            }
            posCtx.stroke();
            // Draw dashed curve with animation
            posCtx.beginPath();
            posCtx.setLineDash([5, 3]);
            posCtx.strokeStyle = '#666';
            
            const dashedPointsToDraw = Math.floor(posData.dashedPoints.length * posAnimationProgress);
            for (let i = 0; i < dashedPointsToDraw; i++) {
                if (i === 0) {
                    posCtx.moveTo(posData.dashedPoints[i].x, posData.dashedPoints[i].y);
                } else {
                    posCtx.lineTo(posData.dashedPoints[i].x, posData.dashedPoints[i].y);
                }
            }
            posCtx.stroke();
            posCtx.setLineDash([]);
            
            // Draw axis labels
            posCtx.fillStyle = '#333';
            posCtx.font = '12px Arial';
            posCtx.textAlign = 'center';
            posCtx.fillText('0', margin, height - margin + 15);
            posCtx.fillText('0.5', margin + innerWidth * 0.5, height - margin + 15);
            posCtx.fillText('1', width - margin, height - margin + 15);
            posCtx.fillText('position', width / 2, height - 5);
            
            posCtx.textAlign = 'right';
            posCtx.fillText('0', margin - 5, height - margin + 5);
            posCtx.fillText('20', margin - 5, height - margin - innerHeight * 0.5 + 5);
            posCtx.fillText('40', margin - 5, margin + 5);
            // Continue animation
            if (posAnimationProgress < 1) {
                posAnimationProgress += 0.01;
                posAnimationId = requestAnimationFrame(animatePositionChart);
            }
        }
        
        // Generate curve points for position chart
        function generateCurvePoints() {
            const width = 400;
            const height = 300;
            const margin = 40;
            const innerWidth = width - 2 * margin;
            const innerHeight = height - 2 * margin;
            
            // Clear existing points
            posData.curvePoints = [];
            posData.dashedPoints = [];
            
            // Generate solid curve points s(simplified line segments)
            const solidSegments = [
                { x: 0.1, y: 36 },
                { x: 0.4, y: 32 },
                { x: 0.7, y: 28 },
            
                 { x: 0.9, y: 22 }
            ];
            // Generate dashed curve points (simplified line segments)
            const dashedSegments = [
                { x: 0.1, y: 38 },
                { x: 0.4, y: 34 },
                { x: 0.7, y: 30 },
               
                 { x: 0.9, y: 24 }
            ];
            // Generate points for solid curve
            generatePointsFromSegments(solidSegments, posData.curvePoints, margin, innerWidth, innerHeight, height);
            // Generate points for dashed curve
            generatePointsFromSegments(dashedSegments, posData.dashedPoints, margin, innerWidth, innerHeight, height);
        }
        
        // Generate points from line segments
        function generatePointsFromSegments(segments, pointArray, margin, innerWidth, innerHeight, chartHeight) {
            // Add start point
            const startPoint = segments[0];
            const startX = margin + startPoint.x * innerWidth;
            const startY = chartHeight - margin - (startPoint.y / 40) * innerHeight;
            pointArray.push({
                x: startX,
                y: startY,
                position: startPoint.x,
                value: startPoint.y
            });
            // Generate points between each segment
            for (let i = 0; i < segments.length - 1; i++) {
                const start = segments[i];
                const end = segments[i + 1];
                const segmentLength = end.x - start.x;
                const step = segmentLength / 20;
                // 20 points per segment
                
                for (let j = 1; j <= 20; j++) {
                    const t = j / 20;
                    const x = start.x + t * segmentLength;
                    const y = start.y + t * (end.y - start.y);
                    // Linear interpolation
                    const pointX = margin + x * innerWidth;
                    const pointY = chartHeight - margin - (y / 40) * innerHeight;
                    pointArray.push({
                        x: pointX,
                        y: pointY,
                        position: x,
                        value: 
                         y
                    });
                }
            }
        }
        
        // Draw axes for a chart
        function drawAxes(ctx, width, height) {
            const margin = 40;
            // Draw axes
            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.moveTo(margin, height - margin);
            ctx.lineTo(width - margin, height - margin);
            
            // Y-axis
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, height - margin);
            
            ctx.stroke();
            
            // Draw arrow heads
            ctx.beginPath();
            ctx.moveTo(width - margin, height - margin);
            ctx.lineTo(width - margin - 5, height - margin - 5);
            ctx.lineTo(width - margin - 5, height - margin + 5);
            ctx.fillStyle = '#333';
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin - 5, margin + 5);
            ctx.lineTo(margin + 5, margin + 5);
            ctx.fill();
        }
        
        // Setup all event listeners
        function setupEventListeners() {
            // Reset button
            document.getElementById('resetBtn').addEventListener('click', startAnimations);
            // Probability chart mouse interaction
            document.getElementById('probabilityChart').addEventListener('mousemove', handleProbabilityChartMouseMove);
            document.getElementById('probabilityChart').addEventListener('mouseout', handleProbabilityChartMouseOut);
            // Position chart mouse interaction
            document.getElementById('positionChart').addEventListener('mousemove', handlePositionChartMouseMove);
            document.getElementById('positionChart').addEventListener('mouseout', handlePositionChartMouseOut);
        }
        
        // Handle mouse move on probability chart
        function handleProbabilityChartMouseMove(event) {
            const rect = event.target.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            // Check if mouse is over any region
            let hoveredRegion = null;
            for (const region of probData.regions) {
                if (x >= region.x && x <= region.x + region.width &&
                    y >= region.y && y <= region.y + region.height) {
                    hoveredRegion = region;
                    break;
                }
            }
            
            if (hoveredRegion) {
                // Show tooltip
                probTooltip.style.opacity = '1';
                probTooltip.innerHTML = `<strong>${hoveredRegion.label}</strong><br>${hoveredRegion.value}`;
                probTooltip.style.left = `${event.pageX + 10}px`;
                probTooltip.style.top = `${event.pageY + 10}px`;
                // Redraw chart with highlighted region
                probCtx.clearRect(0, 0, 400, 300);
                drawAxes(probCtx, 400, 300);
                
                // Redraw all elements
                animateProbabilityChart();
                // Highlight the region
                probCtx.fillStyle = 'rgba(150, 100, 200, 0.7)';
                probCtx.fillRect(hoveredRegion.x, hoveredRegion.y, hoveredRegion.width, hoveredRegion.height);
            } else {
                // Hide tooltip
                probTooltip.style.opacity = '0';
            }
        }
        
        // Handle mouse out from probability chart
        function handleProbabilityChartMouseOut() {
            probTooltip.style.opacity = '0';
            // Redraw chart without highlight
            animateProbabilityChart();
        }
        
        // Handle mouse move on position chart
        function handlePositionChartMouseMove(event) {
            const rect = event.target.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            // Find closest point on either curve
            let closestPoint = null;
            let minDistance = Infinity;
            let pointType = '';
            
            // Check solid curve points
            for (const point of posData.curvePoints) {
                const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
                if (distance < 15 && distance < minDistance) {
                    minDistance = distance;
                    closestPoint = point;
                    pointType = 'Solid Line';
                }
            }
            
            // Check dashed curve points if no solid point found
            if (!closestPoint) {
                for (const point of posData.dashedPoints) {
             
                     const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
                    if (distance < 15 && distance < minDistance) {
                        minDistance = distance;
                        closestPoint = point;
                        pointType = 'Dashed Line';
                    }
                }
            }
            
            if (closestPoint) {
                // Show tooltip
                posTooltip.style.opacity = '1';
                posTooltip.innerHTML = `${pointType}<br>Position: ${closestPoint.position.toFixed(2)}<br>Value: ${closestPoint.value.toFixed(1)}`;
                posTooltip.style.left = `${event.pageX + 10}px`;
                posTooltip.style.top = `${event.pageY + 10}px`;
                // Change cursor style
                event.target.style.cursor = 'pointer';
            } else {
                // Hide tooltip
                posTooltip.style.opacity = '0';
                event.target.style.cursor = 'default';
            }
        }
        
        // Handle mouse out from position chart
        function handlePositionChartMouseOut() {
            posTooltip.style.opacity = '0';
            // Redraw chart without highlight
            animatePositionChart();
        }
        
        // Start the application when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>">
        </iframe>
    </div>

    <div class="document-container">
        <h2>Document 5: Animated Vector Diagram</h2>
        <iframe title="Document 5: Animated Vector Diagram"
                srcdoc="<!DOCTYPE html>
<html lang=&quot;zh&quot;>
<head>
    <meta charset=&quot;UTF-8&quot;>
    <title>IDV Assignment 3 - Animated Vector Diagram (Final with Arrows)</title>
    <style>
        /* 1. 基础布局 */
        body {
            display: flex;
            flex-direction: column; /* 改为垂直排列，使文字在SVG下方 */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px; /* 增加内边距避免内容贴边 */
            background-color: #f0f0f0;
        }

        /* 文字容器样式 */
       .description {
            max-width: 800px;
            margin-top: 30px;
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        /* 图片样式：自适应宽度，居中显示 */
       .description img {
            max-width: 100%;
            height: auto;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
        }

        /* 2. CSS 动画关键帧定义 */
        @keyframes draw {
            /* 目标状态：偏移量归零，线条完全可见 */
            to {
                stroke-dashoffset: 0;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        /* 3. 通用向量线样式与动画设置 */
       .vector-line {
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            /* 悬停过渡效果 */
            transition: all 0.2s ease-out;
            cursor: default;
            /* 动画应用：持续 1s，线性过渡，保持最终状态 */
            animation: draw 1s linear forwards;
            /* 添加stroke-dasharray以支持动画 - GitHub兼容性修复 */
            stroke-dasharray: 1000;
        }

        /* 4. 四条实线 (边) 样式与悬停效果 */
       .side {
            stroke: #333333;
        }
       .side:hover {
            stroke: #007bff;
            /* 悬停变蓝 */
            stroke-width: 4;
        }

        /* 5. 两条虚线 (对角线) 样式与悬停效果 */
       .diagonal {
            stroke: #00AAAA;
            /* 青色 */
            /* 关键：确保虚线模式被应用 */
            stroke-dasharray: 8 6;
        }
       .diagonal:hover {
            stroke: #00cccc;
            /* 悬停变亮青色 */
            stroke-width: 4;
        }

        /* 6. 网格动画 */
       .grid-animated {
            opacity: 0;
            animation: fadeIn 1.5s ease-out forwards;
        }

        /* 7. 文本和标签样式 */
       .vector-label {
            font-family: Arial, sans-serif;
            font-size: 16px;
            fill: black;
            font-weight: bold;
            opacity: 0;
            /* 延迟 3.0s 淡入 */
            animation: fadeIn 0.5s ease-out 3.0s forwards;
        }
       .sub {
            font-size: 0.8em;
        }
       .sup {
            font-size: 0.7em;
        }
    </style>
</head>
<body>

<svg id=&quot;vector-svg&quot; width=&quot;400&quot; height=&quot;400&quot; viewBox=&quot;0 0 400 400&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;>
    <defs>
        <pattern id=&quot;grid&quot; width=&quot;50&quot; height=&quot;50&quot; patternUnits=&quot;userSpaceOnUse&quot;>
            <path d=&quot;M 50 0 L 0 0 0 50&quot; fill=&quot;none&quot; stroke=&quot;#BBBBBB&quot; stroke-width=&quot;0.5&quot;/>
        </pattern>

        <marker id=&quot;arrowhead-diagonal&quot; 
                viewBox=&quot;0 0 
                 10&quot; 
                refX=&quot;9&quot; refY=&quot;5&quot; 
                markerUnits=&quot;strokeWidth&quot; 
                markerWidth=&quot;6&quot; 
                markerHeight=&quot;6&quot; 
                orient=&quot;auto&quot;>
            <path d=&quot;M 
                 0 0 L 10 5 L 0 10 z&quot; fill=&quot;#00AAAA&quot; />
        </marker>
    </defs>
    
    <rect id=&quot;grid-rect&quot; width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;url(#grid)&quot; class=&quot;grid-animated&quot; style=&quot;opacity: 0;&quot;
    />

    <g id=&quot;parallelogram-sides&quot;>
        <line x1=&quot;50&quot; y1=&quot;250&quot; x2=&quot;200&quot; y2=&quot;250&quot; class=&quot;side vector-line&quot; style=&quot;stroke-dashoffset: 150; animation-delay: 0.0s;&quot;
        />
        <line x1=&quot;200&quot; y1=&quot;250&quot; x2=&quot;250&quot; y2=&quot;100&quot; class=&quot;side vector-line&quot; style=&quot;stroke-dashoffset: 158.1; animation-delay: 0.3s;&quot;
        />
        <line x1=&quot;250&quot; y1=&quot;100&quot; x2=&quot;100&quot; y2=&quot;100&quot; class=&quot;side vector-line&quot; style=&quot;stroke-dashoffset: 150; animation-delay: 0.6s;&quot;
        />
        <line x1=&quot;100&quot; y1=&quot;100&quot; x2=&quot;50&quot; y2=&quot;250&quot; class=&quot;side vector-line&quot; style=&quot;stroke-dashoffset: 158.1; animation-delay: 0.9s;&quot;
        />
    </g>

    <g id=&quot;parallelogram-diagonals&quot;>
        <line x1=&quot;50&quot; y1=&quot;250&quot; x2=&quot;250&quot; y2=&quot;100&quot; class=&quot;diagonal vector-line&quot; style=&quot;stroke-dashoffset: 250; animation-delay: 1.2s;&quot;
         marker-end=&quot;url(#arrowhead-diagonal)&quot; />
        <line x1=&quot;200&quot; y1=&quot;250&quot; x2=&quot;100&quot; y2=&quot;100&quot; class=&quot;diagonal vector-line&quot; style=&quot;stroke-dashoffset: 212.1; animation-delay: 1.5s;&quot;
         marker-end=&quot;url(#arrowhead-diagonal)&quot; />
    </g>

    <g id=&quot;vector-labels&quot;>
        <text x=&quot;50&quot; y=&quot;280&quot; class=&quot;vector-label&quot; text-anchor=&quot;end&quot;>
            e<tspan class=&quot;sub&quot;>2</tspan><tspan class=&quot;sup&quot; dy=&quot;-0.7em&quot;>&beta;</tspan>
        </text>

        <text x=&quot;200&quot; y=&quot;280&quot; class=&quot;vector-label&quot; text-anchor=&quot;middle&quot;>
            e<tspan class=&quot;sub&quot;>1</tspan><tspan class=&quot;sup&quot; dy=&quot;-0.7em&quot;>&beta;</tspan>
        </text>

        <text x=&quot;100&quot; y=&quot;75&quot; class=&quot;vector-label&quot; text-anchor=&quot;middle&quot;>
        
            e<tspan class=&quot;sub&quot;>2</tspan><tspan class=&quot;sup&quot; dy=&quot;-0.7em&quot;>&alpha;</tspan>
        </text>

        <text x=&quot;250&quot; y=&quot;75&quot; class=&quot;vector-label&quot; text-anchor=&quot;start&quot;>
            e<tspan class=&quot;sub&quot;>1</tspan><tspan class=&quot;sup&quot; dy=&quot;-0.7em&quot;>&alpha;</tspan>
        </text>
    </g>

</svg>

<div class=&quot;description&quot;>
    <p>1.
        I used Gemini for this chart. First, I uploaded the sample image and the image of the assignment requirements, and gave the instruction: Complete the vector graph (Figure 1) according to the assignment requirements in Figure 2, provide the complete code, and ensure to generate 4 solid lines and 2 dashed lines.</p>
    <img src=&quot;sample-image.png&quot; alt=&quot;Sample Image (Figure 1)&quot;>
    
    <p>2.
        I also tried drawing this chart on Doubao, but the completion was not good.
        I copied the effect content provided by Doubao here to add more requirements.
        The instruction was: Based on this code, add transition effects: grid line fade-in animation (transparency from 0 to 1), vector drawing animation from start point to end point (linear transition), and delayed fade-in effect for labels.
        Add interaction effects: vectors change color and thicken on hover (reasonable feedback), and click the dashed line connections to display coordinate information (meaningful interaction).
        Regenerate a complete code for me.</p>
    
    <p>3.
        I successfully got the code with effects, but the design of the line segments was still different.
        So I gave the instruction: The two middle lines should still be dashed lines, and no text description is needed below.
        Regenerate the complete code for me.</p>
    <img src=&quot;assignment-requirements.png&quot; alt=&quot;Assignment Requirements Image (Figure 2)&quot;>
    
    <p>4.
        Finally, arrows were missing. So my instruction was: Keep everything else unchanged, and add arrows below the two diagonal lines.</p>
</div>

</body>
</html>">
        </iframe>
    </div>

</body>
</html>